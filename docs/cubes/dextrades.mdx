# DEXTrades Cube

import VideoPlayer from "../../src/components/videoplayer.js";

The DEXTrades cube provides comprehensive information about the dex trading data, such as buyer, seller, token prices, pairs, transactions, etc.

> **Advanced Usage Note**: This documentation includes advanced patterns for processing DEXTrades data based on production implementations. These patterns help handle complex scenarios like multi-hop swaps, proxy contracts, and proper volume calculations.

> Import Note: If there is a trade between 2 addresses, the details in `Buy{}` dropdown are pool details, and the information displayed in the DEXTrades cube is from the pool's perspective.

![](/img/tokenAB.png)

Let's understand the concept of buyer and seller. Token X and token Y swap as above.

If we see the trade from user A's side, then we get the following:

- User A becomes the seller of token X.
- User A becomes the buyer of token Y.

Now, if we see the trade from a user B side, we get the following.

- User B becomes the seller of token Y.
- User B becomes the buyer of token X.

Therefore, buyers and sellers change relatively when the trade sides change.

It is important to note that a pool is always involved; whenever any trade occurs between two traders, one must be a pool. Thus, we are considering User B as a pool.

## Understanding DEXTrade Cube data

Next, we understand how the Dextrades Cube displays the result:

Take this query for example:

```
{
  EVM(network: eth, dataset: archive) {
    DEXTrades(
      orderBy: {descending: Block_Time}
      limit: {count: 50}
      where: {TransactionStatus: {Success: true}, Block: {Number: {eq: "23674719"}}, Transaction: {Hash: {is: "0x0891b30722d44284d0c110c761190ecd6ad0f33946835bbde164561d847f5c87"}}}
    ) {
      Trade {
        Buy {
          Buyer
          Amount
          Price
          Currency {
            SmartContract
            Name
          }
        }
        Dex {
          Pair {
            Name
            SmartContract
          }
          ProtocolName
        }
        Sell {
          Buyer
          Amount
          Currency {
            Name
            SmartContract
          }
        }
      }
      Transaction {
        Hash
      }
    }
  }
}


```

Output

```
{
  "EVM": {
    "DEXTrades": [
      {
        "Trade": {
          "Buy": {
            "Amount": "4002.603343842926485635",
            "Buyer": "0xad4e4954b2f22525f5c9d7e7182fff9cf251d0f7",
            "Currency": {
              "Name": "MUSKITO Token",
              "SmartContract": "0x7ef790d9bccc87989be0fdb88ffb955bec3d5e92"
            },
            "Price": 6.700259580759855e-9
          },
          "Dex": {
            "Pair": {
              "Name": "Uniswap V2",
              "SmartContract": "0xad4e4954b2f22525f5c9d7e7182fff9cf251d0f7"
            },
            "ProtocolName": "uniswap_v2"
          },
          "Sell": {
            "Amount": "0.000026818481402565",
            "Buyer": "0x5fbf1aba26bf1493cd7677ad4ec25d96a91ab0ec",
            "Currency": {
              "Name": "Wrapped Ether",
              "SmartContract": "0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2"
            }
          }
        },
        "Transaction": {
          "Hash": "0x0891b30722d44284d0c110c761190ecd6ad0f33946835bbde164561d847f5c87"
        }
      }
    ]
  }
}
```

### Analyzing the DEXTrades Output

Let's break down how DEXTrades presents data from the pool's perspective:

**Key Observations:**

1. **Pool Identification**: The `Buy.Buyer` address matches the `Dex.Pair.SmartContract` address.

2. **Buy Side (Pool's Perspective)**:

   - **Currency**: The token that the pool received (project token)
   - **Amount**: Quantity of tokens the pool received
   - **Buyer**: Pool address (the pool is "buying" these tokens)
   - **Price**: Current trading price per token

3. **Sell Side (Pool's Perspective)**:
   - **Currency**: The payment token (WETH, stablecoins, etc.)
   - **Amount**: Quantity of payment tokens the pool gave out
   - **Buyer**: User address who received the payment tokens

**What Actually Happens:**

From the **pool's perspective** (which is what DEXTrades shows):

- The pool **bought** project tokens (received them from user)
- The pool **sold** payment tokens (gave them to user)

From the **user's perspective** (the actual trader):

- User **sold** project tokens to the pool
- User **bought** payment tokens (WETH/stablecoins) in return

## Multi-Hop Trade Detection and Processing

When processing DEXTrades data in production applications, it's crucial to handle multi-hop swaps correctly. Multi-hop trades occur when a single transaction contains multiple DEX trades that are part of one logical swap operation (e.g., Token A → WETH → Token B).

### Identifying Multi-Hop Trades

Multi-hop trades can be detected by:

1. **Same Transaction Hash**: All trades in a multi-hop swap share the same transaction hash
2. **Sequential Processing**: Trades appear in sequence within the same block following the Trade_Index
3. **Token Chain Logic**: The sell token of one trade matches the buy token of the next

### Processing Strategy

For multi-hop trades, use this approach:

- **Token Identification**: Use the first hop to identify the actual token being swapped (not the intermediate tokens)
- **Volume Calculation**: Use the last hop to determine the final payment amount
- **Direction Detection**: Check the signer's role in the final hop to determine if it's a buy or sell

```python
# Example pattern for multi-hop detection
if tx_hash in processed_transactions:
    # This is part of a multi-hop swap
    first_hop = processed_transactions[tx_hash][0]
    current_hop = trade_data  # Last hop seen

    # Get actual token from first hop (exclude payment tokens)
    actual_token = get_non_payment_token(first_hop)

    # Get final volume from last hop payment side
    final_volume = get_payment_side_amount(current_hop)

    # Determine buy/sell from signer's role in last hop
    is_buy = signer_is_buyer_in_final_hop(current_hop, signer)
```

### Payment Token Classification

Different token types require different processing logic:

- **Native Tokens**: `0x` (ETH), direct BNB trades
- **Wrapped Tokens**: WETH, WBNB - used for volume calculations
- **Stablecoins**: USDT, USDC, DAI - also payment tokens
- **Other Tokens**: Project tokens, memecoins, etc.

## Filtering in DEXTrades Cube

Filtering helps you retrieve the data you are looking for. DexTrades Cube can filter trades based on buy currency, sell currency, buyer, seller, dex, pool, sender, receiver, transaction, time, etc.

Everything inside the “where” clause acts as a filter; it uses the ‘AND’ condition by default.

In this example, we retrieve the trade currencies and their trader's details in the ethereum network. Therefore, we use the Trade Buy currency SmartContract filter to specify the buy “currency address” and the Trade Buy Seller to specify the “seller address.” We can extract trade information from the buy and sell sides using these filters. [Use this link to execute the following API.](https://ide.bitquery.io/seller-buyer-block-time-as-filters)

```
{
  EVM(dataset: archive, network: eth) {
    buyside: DEXTrades(
      limit: { count: 10 }
      orderBy: { descending: Block_Time }
      where: {
        Trade: {
          Buy: {
            Currency: {
              SmartContract: {
                is: "0x5283d291dbcf85356a21ba090e6db59121208b44"
              }
            }
            Seller: { is: "0x1111111254eeb25477b68fb85ed929f73a960582" }
          }
        }
        Block: {
          Time: { since: "2023-03-03T01:00:00Z", till: "2023-03-05T05:15:23Z" }
        }
      }
    ) {
      Block {
        Number
        Time
      }
      Transaction {
        From
        To
        Hash
      }
      Trade {
        Buy {
          Amount
          Buyer
          Currency {
            Name
            Symbol
            SmartContract
          }
          Seller
          Price
        }
        Sell {
          Amount
          Buyer
          Currency {
            Name
            SmartContract
            Symbol
          }
          Seller
          Price
        }
      }
    }
    sellside: DEXTrades(
      limit: { count: 10 }
      orderBy: { descending: Block_Time }
      where: {
        Trade: {
          Sell: {
            Currency: {
            SmartContract: {
                is: "0x5283d291dbcf85356a21ba090e6db59121208b44"
              }
            }
            Buyer: { is: "0x1111111254eeb25477b68fb85ed929f73a960582" }
          }
        }
        Block: {
          Time: { since: "2023-03-03T01:00:00Z", till: "2023-03-05T05:15:23Z" }
        }
      }
    ) {
      Block {
        Number
        Time
      }
      Transaction {
        From
        To
        Hash
      }
      Trade {
        Buy {
          Amount
          Buyer
          Currency {
            Name
            Symbol
            SmartContract
          }
          Seller
          Price
        }
        Sell {
          Amount
          Buyer
          Currency {
            Name
            SmartContract
            Symbol
          }
          Seller
          Price
        }
      }
    }
  }
}
```

Next, we retrieve trade currency details on a particular dex in the ethereum network. Therefore, we use the Trade Buy Currency filter to specify the “currency address” and the Trade Dex OwnerAddress filter to specify the “Dex address.”

Run this API to retrieve the trade activities of WETH ("0xc02….") in the Uniswap v3 factory " 0x1f98.."

## Advanced Buyer/Seller Logic and Proxy Contracts

### Understanding BitQuery's Buy/Sell Fields

In EVM chains, DEXTrades data, as we see above, the Buy fields represent the pool's events.

### Handling Different Scenarios

When processing trades, check multiple scenarios for accurate buyer/seller identification:

#### Scenario 1: Direct Signer Matches

```python
# Check if signer is directly in buy/sell fields
if signer == buy_buyer:
    # Signer bought the token
    process_as_buy()
elif signer == sell_seller:
    # Signer sold the token
    process_as_sell()
```

#### Scenario 2: Proxy Contract Logic

When the signer doesn't appear in buyer/seller fields (common with proxy contracts):

```python
# Find consistent party across both sides
if buy_buyer == sell_seller:
    # This party appears to buy token and sell payment
    # BUT for proxy contracts, logic is inverted
    if signer != buy_buyer:
        # Signer used proxy -> opposite action
        process_as_sell()  # Inverted logic
elif buy_seller == sell_buyer:
    # This party appears to sell token and buy payment
    # BUT for proxy contracts, logic is inverted
    if signer != buy_seller:
        # Signer used proxy -> opposite action
        process_as_buy()   # Inverted logic
```

### Trade Type Classification

Different trade types require specific handling:

#### 1. Native Token Trades

```graphql
# Direct BNB/ETH trades (sell_contract = "0x")
where: {
  Trade: {
    Sell: { Currency: { SmartContract: { is: "0x" } } }
  }
}
```

#### 2. Wrapped Token Trades

```graphql
# WETH/WBNB trades
where: {
  Trade: {
    Buy: { Currency: { SmartContract: { is: "0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2" } } }
  }
}
```

#### 3. Token-to-Token Swaps

```graphql
# Both sides are tokens (not native/wrapped)
where: {
  Trade: {
    Buy: { Currency: { SmartContract: { not: "0x" } } },
    Sell: { Currency: { SmartContract: { not: "0x" } } }
  }
}
```

## Metrics in DEXTrades Cube

Metrics allow for sum, count, average, median, maximum, minimum, and more calculations

The count metric can easily retrieve a specific token's total number of trades. [Run this API](https://ide.bitquery.io/Count-of-trade-on-Uniswap-of-pepe) to find the total trades of [PEPE](https://explorer.bitquery.io/ethereum/token/0x6982508145454ce325ddbe47a25d4ec3d2311933) “0x698…” tokens in the [Uniswap v3 factory](https://explorer.bitquery.io/ethereum/token/0x6982508145454ce325ddbe47a25d4ec3d2311933) “0x1f984…” in the ethereum network.

```
query MyQuery {
  EVM(dataset: archive, network: eth) {
    DEXTradeByTokens(
      where: {TransactionStatus: {Success: true},
        Trade: {Currency:
          {SmartContract:
            {is: "0x6982508145454ce325ddbe47a25d4ec3d2311933"}},
          Dex:
          {OwnerAddress:
            {is: "0x1f98431c8ad98523631ae4a59f267346ea31f984"}}},
        Block: {Date:
          {since: "2024-01-01", till: "2024-06-02"}}}
    ) {
      total_trades: count
    }
  }
}

```

## How Does Bitquery Calculate USD Price for a Token?

Bitquery calculates the token price using a simple formula:

**UsdPrice of token 1 = amount2 in USD / amount1**
**UsdPrice of token 2 = amount1 in USD / amount2**

If either of these amounts is missing, the price cannot be determined. To better understand token prices, one must first examine the trade amounts involved.

It’s important to note that this “price” is not the actual market price of the token, but rather a derivative based on the trade amounts.

**Example: BAR/WETH Pair**  
**BAR Price in USD = WETH amount in USD / Amount of BAR tokens**  
**WETH Price in USD = BAR amount in USD / Amount of WETH tokens**

In this example, the second calculation (WETH Price) may not be accurate because the **BAR amount in USD is unknown**.

**Example: WETH/USDT Pair**  
**USDT Price in USD = WETH amount in USD / Amount of USDT tokens**  
**WETH Price in USD = USDT amount in USD / Amount of WETH tokens**

In this case, both values make sense, as both **WETH** and **USDT** can be valued in USD directly.

## Common Edge Cases and Filtering Strategies

### Filtering MEV Bots and Unwanted Trades

Production applications often need to filter out certain types of trades:

```graphql
# Filter out specific MEV bot contracts
query FilterMEVBots {
  EVM(dataset: combined, network: eth) {
    DEXTrades(
      where: {
        Transaction: {
          To: { notIn: ["0x802b65b5d9016621e66003aed0b16615093f328b"] }
        }
      }
    ) {
      # Your trade data
    }
  }
}
```

### Handling Zero Value Trades

Filter out trades with zero amounts or prices:

```graphql
query FilterZeroTrades {
  EVM(dataset: combined, network: eth) {
    DEXTrades(
      where: {
        Trade: {
          Buy: {
            Amount: { gt: "0" },
            PriceInUSD: { gt: 0 }
          },
          Sell: {
            Amount: { gt: "0" },
            PriceInUSD: { gt: 0 }
          }
        }
      }
    ) {
      # Your trade data
    }
  }
}
```

### Identifying Pool vs Trader Addresses

For token-to-token swaps, distinguish between pool addresses and actual traders:

```graphql
# Focus on specific signer addresses (real traders)
query RealTraders {
  EVM(dataset: combined, network: eth) {
    DEXTrades(
      where: {
        Transaction: {
          Signer: { is: "0x742d35Cc6334C0532925a3b8C836f4b98C6b1e96" }
        }
      }
    ) {
      Transaction {
        Signer
      }
      Trade {
        Buy {
          Buyer
          Seller
        }
        Sell {
          Buyer
          Seller
        }
      }
    }
  }
}
```

### Transaction Status Filtering

Always filter for successful transactions:

```graphql
query SuccessfulTrades {
  EVM(dataset: combined, network: eth) {
    DEXTrades(
      where: {
        TransactionStatus: { Success: true }
      }
    ) {
      # Your trade data
    }
  }
}
```

## Video Tutorial | Why PriceInUSD is 0 in Bitquery API response?

<VideoPlayer url="https://youtu.be/OzjOXK8Y0t8" />
